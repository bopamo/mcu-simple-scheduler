<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MSS(MCUSimpleScheduler): MSS Multi Tasking Basic</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSS(MCUSimpleScheduler)
   &#160;<span id="projectnumber">v.0.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li class="current"><a href="pages.html"><span>Info&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_g_e_t__s_t_a_r_t.html">Getting Started with MSS</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">MSS Multi Tasking Basic </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="MSS_TASK"></a>
MSS Task</h1>
<p>MSS Task is based on coroutine concept which allows a function code (in this case the MSS task function code) to suspend at a certain location and then resume at the same spot where it left before. Coroutine enables the possibility to implement a very light weight multi tasking system at the cost of losing the ability to retain the local variables between suspending and re-entering the task code (MSS has only one memory stack shared by the scheduler and all tasks).</p>
<p>This means that when using local variable(s) in its code, a task shall expect that the local variable value to be changed when re-entering the function after suspending it self. Therefore static data type shall be used if the variable value is wished to be retained between suspending and re-entering the task.</p>
<p>Even tough MSS also supports preemptive schedulding (see next section), it doesn't mean that when a lower task is preempted, it will lose the local variable. MSS scheduler preempts the lower priority task by calling a software interrupt which will call the scheduler function again and execute the higher priority task. So basically the local variable context of the preempted task is stored safely on the top of memory stack.</p>
<p>In general a MSS task looks like the following:</p>
<div class="fragment"><div class="line">   <span class="keywordtype">void</span> a_mss_task(<span class="keywordtype">void</span> *param)</div>
<div class="line">   {</div>
<div class="line">     <span class="keyword">static</span> <a class="code" href="group___m_s_s___general___a_p_i.html#ga1b514d1f1ba2562f7d9cc4188812d27c">mss_task_ctx_t</a> task_ctx = <a class="code" href="group___m_s_s___general___a_p_i.html#ga89652a48906b6a57f9d1f9ca8aa8ed98">MSS_TASK_CTX_STATE_INIT_VAL</a>;</div>
<div class="line">     <span class="comment">// other variable declaration - be careful of using local variables</span></div>
<div class="line">     </div>
<div class="line">     <a class="code" href="group___m_s_s___general___a_p_i.html#gafc93e1a92a96dd38101b17352b9c2510">MSS_BEGIN</a>(task_ctx); <span class="comment">// must be the first instruction in the task code</span></div>
<div class="line">  </div>
<div class="line">     <span class="comment">// initialization code</span></div>
<div class="line">  </div>
<div class="line">     <span class="keywordflow">while</span>(1)</div>
<div class="line">     {</div>
<div class="line">       <span class="comment">// do some tasks</span></div>
<div class="line">  </div>
<div class="line">       <a class="code" href="group___m_s_s___general___a_p_i.html#gad7fca9b7d54406382ea25ff40e347fff">MSS_RETURN</a>(task_ctx); <span class="comment">// suspend task temporarily</span></div>
<div class="line">  </div>
<div class="line">       <span class="comment">// do another tasks</span></div>
<div class="line">     }</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="group___m_s_s___general___a_p_i.html#ga86841573ef85e1761b976092685b517b">MSS_FINISH</a>(); <span class="comment">// last instruction in task code</span></div>
<div class="line">   }</div>
</div><!-- fragment --><p>As can be seen above, a task needs a static variable with mss_task_ctx_t type (initialized with value MSS_TASK_CTX_STATE_INIT_VAL) to store the information in which code part the function has been suspended last time.</p>
<p><a class="el" href="group___m_s_s___general___a_p_i.html#gafc93e1a92a96dd38101b17352b9c2510">MSS_BEGIN(ctx)</a> shall be the first instruction in the task code, while <a class="el" href="group___m_s_s___general___a_p_i.html#ga86841573ef85e1761b976092685b517b">MSS_FINISH()</a> as the last one. When a task want to give up a CPU, it calls the <a class="el" href="group___m_s_s___general___a_p_i.html#gad7fca9b7d54406382ea25ff40e347fff">MSS_RETURN(ctx)</a> which also stores the information of the address where the task is left. The <a class="el" href="group___m_s_s___general___a_p_i.html#gad7fca9b7d54406382ea25ff40e347fff">MSS_RETURN()</a> is also encapsulated by some macro functions of MSS modules, please refer to the API documentation for further information.</p>
<p>The implementation of coroutine in MSS is derived from: <a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a> and similar to the implementation of protothreads: <a href="http://dunkels.com/adam/pt/">http://dunkels.com/adam/pt/</a></p>
<h1><a class="anchor" id="MSS_Scheduling"></a>
MSS Scheduling</h1>
<p>MSS supports two basic scheduling policy depending on the configuration value of MSS_PREEMPTIVE_SCHEDULING in <a class="el" href="mss__cfg_8h.html" title="mcu simple scheduler configuration header file">mss_cfg.h</a>:</p>
<ul>
<li>Cooperative Scheduling (MSS_PREEMPTIVE_SCHEDULING = FALSE): in the cooperative scheduling mode, a task will be executed as long as it hasn't given up the CPU by calling the <a class="el" href="group___m_s_s___general___a_p_i.html#gad7fca9b7d54406382ea25ff40e347fff">MSS_RETURN()</a> function. The scheduler always looks for the highest priority task which is ready to be executed after the running task suspends. The advantage of this scheduling policy is that it needs less memory stack than the preemptive mode, however the disadvatage is that higher prioirty task might expect longer lattency since it can't preempt a running task with lower priority.</li>
</ul>
<ul>
<li>Preemptive Scheduling (MSS_PREEMPTIVE_SCHEDULING = TRUE): in the preemptive scheduling mode, a higher priority task can preempt a running task which has lower priority. Altough the MSS task is based on coroutine concept, it can be assured that a preempted task will not lose its local variable when it is preempted by the higher priority task. The main advantage of this scheduling policy is that preemption which increase the responsiveness of higher priority task, however in this policy the scheduler can go deep into the memory stack, and therefore a bigger memory stack is needed to prevent stack overflow. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 14 2013 23:41:46 for MSS(MCUSimpleScheduler) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
